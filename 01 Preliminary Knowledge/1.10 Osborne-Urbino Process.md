# 01 Prelieliminary Knowledge

## 1.10 Osborne-Urbino Process

### Osborne-Urbino Process
Osborne-Urbino Process 是一种用于解决矩阵平衡问题（Matrix Balancing Problem）的迭代算法。矩阵平衡问题在许多领域中都有应用，例如经济学、统计学、机器学习（如概率图模型）和网络流分析等。该问题的目标是通过调整矩阵的行和列权重，使得矩阵在某种意义下达到平衡状态。

#### 矩阵平衡问题
给定一个非负矩阵$A \in \mathbb{R}^{n \times n}$，矩阵平衡的目标是找到两个对角矩阵$D_1$和$D_2$，使得$B = D_1 A D_2$在某种意义下是平衡的。常见的平衡标准包括：
- 矩阵$B$每行的和等于1（行平衡）；
- 矩阵$B$每列的和等于1（列平衡）；
- 矩阵$B$每行和每列的和都等于1（双随机平衡——Doubly Stochastic Balancing）。

#### Osborne-Urbino算法
Osborne-Urbino 算法是一种迭代算法，通过交替调整行和列的权重来逐步使矩阵达到平衡状态。其核心思想是通过迭代更新对角矩阵$D_1$和$D_2$，使得矩阵$B$逐渐满足行和列的平衡条件。

1. 初始化：
   - 设$D_1$和$D_2$为单位矩阵；
   - 计算出事矩阵$B = D_1 A D_2$；
2. 迭代更新：
   - 行平衡：调整$D_1^{k+1} = diag (\frac {1}{\sum_j B_{ij}}) D_1^k$，使得每行的和为1;
   - 列平衡：调整$D_2^{k+1} = diag (\frac {1}{\sum_i B_{ij}}) D_2^k$，使得每行的和为1;
   - 更新矩阵：$B=D_1^{k+1} A D_2^{k+1}$
3. 终止条件：
   - 当矩阵$B$的行和列的和接近 1（满足一定的收敛条件）时，算法终止.

#### 优点
- 算法逻辑清晰，简单易实现
- 在大多数情况下，算法能够收敛到平衡矩阵

#### 缺点
- 收敛速度较慢，特别是在矩阵规模较大时
- 对出事条件敏感，对于某些特殊矩阵，算法可能无法收敛到平衡矩阵


```python
#### Example
```


```python
import numpy as np
```


```python
def osborne_urbino(matrix, max_iter=1000, tol=1e-6):
    """
    Osborne-Urbino matrix balancing algorithm.

    Parameters:
    matrix (np.ndarray): The input square matrix to be balanced.
    max_iter (int): Maximum number of iterations.
    tol (float): Tolerance for convergence.

    Returns:
    tuple: A tuple containing the balanced matrix, row scaling matrix, and column scaling matrix.
    """
    n = matrix.shape[0]
    if matrix.shape[1] != n:
        raise ValueError("Input matrix must be square.")

    row_scaling = np.eye(n)  # Initialize row scaling matrix
    col_scaling = np.eye(n)  # Initialize column scaling matrix

    for iteration in range(max_iter):
        balanced_matrix = row_scaling @ matrix @ col_scaling  # Compute the current balanced matrix

        # Check convergence conditions
        row_sums = balanced_matrix.sum(axis=1)
        col_sums = balanced_matrix.sum(axis=0)
        if np.allclose(row_sums, 1, atol=tol) and np.allclose(col_sums, 1, atol=tol):
            print(f"Converged in {iteration} iterations.")
            return balanced_matrix, row_scaling, col_scaling

        # Update row scaling matrix
        row_scaling = np.diag(1 / row_sums) @ row_scaling

        # Update column scaling matrix
        col_scaling = col_scaling @ np.diag(1 / col_sums)

    print("Reached maximum iterations without convergence.")
    return balanced_matrix, row_scaling, col_scaling
```


```python
# Example
A = np.array([[2, 1], [1, 2]], dtype=float)
B, D1, D2 = osborne_urbino(A, tol=1e-3)
print("Balanced matrix B:")
print(B)
print("Row scaling matrix D1:")
print(D1)
print("Column scaling matrix D2:")
print(D2)
```

    Reached maximum iterations without convergence.
    Balanced matrix B:
    [[0.22222222 0.11111111]
     [0.11111111 0.22222222]]
    Row scaling matrix D1:
    [[1. 0.]
     [0. 1.]]
    Column scaling matrix D2:
    [[1. 0.]
     [0. 1.]]

